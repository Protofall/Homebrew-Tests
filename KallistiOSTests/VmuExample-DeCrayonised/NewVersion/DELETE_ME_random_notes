// New system plan

// (IMPLEMENTED)
// - The add functions return an int ID. We add all variables that ever existed
//     - static uint32_t id = 0; then id++ at the end of the function to get the new id values
// - The add function also has a field for the version removed. Set to 0 if still present
// - The remove function will be deleted since its functionality is useless
// - Those remove handling defines will be deleted


// (UNIMPLEMENTED)
// - So now when a variable is deleted and we want to handle how its value influences the new savefile system, the user defined function handles that
//     - I'm not 100% sure how it will work yet, but it will use the IDs returned by the add function to reference different variables throughout the history of the savefile. The user would also have if statements with version ids to control when we change a variable and how.
//     - The parameters will probable be two crayon_savefile_data_t pointers and the two version numbers (One struct is of current version and other is of an older version)

// - void *crayon_savefile_get_var(uint32_t id, crayon_savefile_data_t *data, crayon_savefile_history_t *history, crayon_savefile_version_t version);
//     - Could be used to get a pointer to the right block of memory. However it would be slow since they need to traverse the whole history linked list. Maybe in the solidify stage the linked list is converted into an array so its as simple as using the id to get the right history node. But even then, how do we know where the value is in data?

// ALTERNATIVE APPROACH
// - A function that returns an array of unions such that element X contains a pointer to the block of memory for variable with id X. The function would need the history list, target version and savedata. This does mean the user will need to be aware of what kind of pointer they use since they're handling a union which is a bit strange to most people.
//     - crayon_savefile_variable_ptr_t *crayon_savefile_get_variable_pointers(crayon_savefile_data_t *data, crayon_savefile_history_t *history, crayon_savefile_version_t version);
//     - They would only need to call this for the old savefile since they can just use their own var pointers for the new savedata (The one thats a part of details)
//     - Maybe the union array should be made before the user function is called and its passed in by reference instead of crayon_savefile_data_t *loaded_data? Also we don't really need to pass in crayon_savefile_data_t *latest_data either if our variables are global (Which they should be). So parameters is just the union array and version numbers
//     - Maybe the array contains as many elements as all-time variables, but vars not in the current version are set to zero 

// What purpose does the history list have?
//     - Construct a crayon_savefile_data_t struct for any savefile version
//     - Locate where where any variable of id X would be in that crayon_savefile_data_t struct











// COMMAND
// make clean-pc && make pc && cp pc_savefile_backups/v0-Modified/SAVE_DEMO3.s saves/














//FINISH THE SAVEFILE DELETE FUNCTION


//Notes:

//I don't think the pointers the user has are mapped to the variables right


#include <stdio.h>

int hidden[10]; //The actual values we manipulate
int ** mapper;  //The variable in the history struct
int * visible;  //This is what the user controls

void func(void ** lol){
    mapper = (int**)lol;
}

#define USE_FUNCTION

int main()
{
    #ifdef USE_FUNCTION
    func(&visible);    //Doesn't set it right
    #else
    mapper = &visible;
    #endif
    *mapper = &hidden[4];
    
    for(int i= 0; i < 10; i++){
        hidden[i] = 500 + i;
    }
    
    printf("%d", visible[0]);

    return 0;
}







#include <stdio.h>
#include <stdint.h>

typedef union crayon_savefile_variable_ptr{
    double *doubles;
    float *floats;
    uint32_t *u32;
    int32_t *s32;
    uint16_t *u16;
    int16_t *s16;
    uint8_t *u8;
    int8_t *s8;
    char *chars;
} crayon_savefile_variable_ptr_t;

void * func(void * a, uint8_t type){
    if(type == 0){
        return (uint8_t*)a;
    }
    if(type == 1){
        return (int8_t*)a;
    }
}

int main()
{
    crayon_savefile_variable_ptr_t a;
    a.s8 = NULL;
    
    int8_t *b = func(&a, 1);
    
    printf("Hello World\n");

    return 0;
}







//FUNCTIONS WITH NO DREAMCAST SPECIFIC CODE
uint8_t crayon_misc_is_big_endian();
uint8_t crayon_savefile_delete_savedata(crayon_savefile_details_t *details);    //UNFINISHED
void crayon_savefile_free(crayon_savefile_details_t *details);
uint8_t crayon_savefile_get_valid_function(uint32_t function);
void crayon_savefile_update_valid_saves(crayon_savefile_details_t *details, uint8_t modes);
void crayon_savefile_solidify(crayon_savefile_details_t *details);
crayon_savefile_history_t *crayon_savefile_remove_variable(crayon_savefile_details_t *details,
    crayon_savefile_history_t *target_node, uint8_t remove_command, crayon_savefile_history_t *transfer_var,
    crayon_savefile_version_t version);
void __attribute__((weak)) crayon_savefile_serialise(crayon_savefile_data_t *sf_data, uint8_t *pkg_data);
void __attribute__((weak)) crayon_savefile_deserialise(crayon_savefile_data_t *sf_data, uint8_t *pkg_data,
    uint32_t pkg_size);
crayon_savefile_history_t *crayon_savefile_add_variable(crayon_savefile_details_t *details, void **data_ptr,
    uint8_t data_type, uint16_t length, const void *default_value, crayon_savefile_version_t version);
uint8_t crayon_savefile_set_string(crayon_savefile_details_t *details, const char *string, uint8_t string_id);
uint8_t crayon_savefile_get_memcard_bit(uint8_t memcard_bitmap, uint8_t save_device_id);
void crayon_savefile_set_memcard_bit(uint8_t *memcard_bitmap, uint8_t save_device_id);

//TECHNICALLY DREAMCAST ONLY, BUT WORKS ON PC
uint8_t crayon_savefile_add_eyecatcher(crayon_savefile_details_t *details, const char *eyecatch_path);
uint8_t crayon_savefile_add_icon(crayon_savefile_details_t *details, const char *image, const char *palette,
    uint8_t icon_anim_count, uint16_t icon_anim_speed);
void crayon_savefile_free_icon(crayon_savefile_details_t *details);
void crayon_savefile_free_eyecatcher(crayon_savefile_details_t *details);
uint16_t crayon_savefile_bytes_to_blocks(size_t bytes);
vec2_s8_t crayon_savefile_dreamcast_get_port_and_slot(int8_t savefile_device_id);


//ALREADY FIXED
uint16_t crayon_savefile_detail_string_length(uint8_t string_id);
void crayon_vmu_display_icon(uint8_t vmu_bitmap, void *icon);
uint8_t crayon_savefile_init_savefile_details(crayon_savefile_details_t *details, const char *save_name,
    crayon_savefile_version_t version);
uint16_t crayon_savefile_device_free_blocks(int8_t port, int8_t slot);
int16_t crayon_savefile_get_save_block_count(crayon_savefile_details_t *details);
uint8_t crayon_savefile_check_device_for_function(uint32_t function, int8_t save_device_id);
uint8_t crayon_savefile_save_savedata(crayon_savefile_details_t *details);
uint8_t crayon_savefile_check_savedata(crayon_savefile_details_t *details, int8_t save_device_id);
uint8_t crayon_savefile_load_savedata(crayon_savefile_details_t *details);
